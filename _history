{"entries":[{"timestamp":1749565338956,"editorVersion":"7.0.61","changes":[{"type":"edited","filename":"main.blocks","patch":[{"diffs":[[0,"http"],[-1,"s"],[0,"://"],[-1,"developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" id=\"v^M{nd)JM1ZO4!+{d!vy\" x=\"20\" y=\"20"],[1,"www.w3.org/1999/xhtml\">\n  <block type=\"pxt-on-start"],[0,"\"></"]],"start1":12,"start2":12,"length1":135,"length2":62},{"diffs":[[0,"</block>"],[1,"\n  "],[0,"<block t"]],"start1":72,"start2":72,"length1":16,"length2":19},{"diffs":[[0,"ver\""],[-1," id=\"rcM5w!E8T7Ri9Yf7c9JI\" x=\"225\" y=\"20\""],[0,"></b"]],"start1":107,"start2":107,"length1":49,"length2":8},{"diffs":[[0,"</block>"],[1,"\n"],[0,"</xml>"]],"start1":112,"start2":112,"length1":14,"length2":15}]},{"type":"edited","filename":"main.ts","patch":[{"diffs":[[-1,"enum mySerialPin {\n    //% block=\"P0\"\n    P0 = SerialPin.P0,\n    //% block=\"P1\"\n    P1 = SerialPin.P1,\n    //% block=\"P2\"\n    P2 = SerialPin.P2\n}\nenum TrameType {\n    //% block=\"GNGGA\"\n    GNGGA,\n    //% block=\"GNGLL\"\n    GNGLL,\n    //% block=\"GPGSA\"\n    GPGSA,\n    //% block=\"BDGSA\"\n    BDGSA,\n    //% block=\"GPGSV\"\n    GPGSV,\n    //% block=\"BDGSV\"\n    BDGSV,\n    //% block=\"GNRMC\"\n    GNRMC,\n    //% block=\"GNVTG\"\n    GNVTG,\n    //% block=\"GNZDA\"\n    GNZDA\n}\nenum ChampTypeGGA {\n    /** Renvoie l'heure UTC au format HH:MM:SS.SSS*/\n    //% block=\"HEURE UTC (HH:MM:SS.SSS)\"\n    HEURE,\n    /** Renvoie la latitude en degré décimal*/\n    //% block=\"LATITUDE (Degré Décimal)\"\n    LATITUDE,\n    /** Renvoie la longitude en degré décimal*/\n    //% block=\"LONGITUDE (Degré Décimal)\"\n    LONGITUDE,\n    /** Renvoie la valeur du fix */\n    //% block=\"FIX (0 : non valide, >=1 : valide)\"\n    FIX,\n    /** Renvoie le nombre de satellites utilisés */\n    //% block=\"NBSAT (nb de satelittes utilisés)\"\n    NBSAT,\n    /** Renvoie l'altitude en mètre */\n    //% block=\"ALTITUDE (en m)\"\n    ALTITUDE,\n    /** Renvoie la précision horizontale en mètre */\n    //% block=\"HDOP (précision lat/lon en m)\"\n    HDOP,\n    /** Renvoie la précision verticale en mètre */\n    //% block=\"VDOP (précision altitude en m)\"\n    VDOP\n}\nenum ChampTypeGLL {\n    /** Renvoie l'heure UTC au format HH:MM:SS.SSS*/\n    //% block=\"HEURE UTC (HH:MM:SS.SSS)\"\n    HEURE,\n    /** Renvoie la latitude en degré décimal*/\n    //% block=\"LATITUDE (Degré Décimal)\"\n    LATITUDE,\n    /** Renvoie la longitude en degré décimal*/\n    //% block=\"LONGITUDE (Degré Décimal)\"\n    LONGITUDE,\n    /** Renvoie un indicateur de status (\"A\" : valide, \"V\": non valide) */\n    //% block=\"ETAT ('A' : valide, 'V': non valide)\"\n    ETAT\n}\nenum ChampTypeGSA {\n    /** Renvoie le type de mode \"A\" : Automatic ou \"M\" : Manuel*/\n    //% block=\"MODE ('A' : Automatic, 'M' : Manuel)\"\n    MODE,\n    /** Renvoie le type de fix (1 : Not available, 2: 2D, 3 : 3D) */\n    //% block=\"TYPE FIX (1 : Not available, 2: 2D, 3 : 3D)\"\n    FONCTIONNEMENT,\n    /** Renvoie les valeurs des identifiants PRN des satellites utilisés */\n    //% block=\"Identifiants PRN des Satellites utilisés\"\n    IDSAT,\n    /** Renvoie la précision globale en mètre */\n    //% block=\"PDOP (précision globale en m)\"\n    PDOP,\n    /** Renvoie la précision horizontale en mètre */\n    //% block=\"HDOP (précision lat/lon en m)\"\n    HDOP,\n    /** Renvoie la précision verticale en mètre */\n    //% block=\"VDOP (précision altitude en m)\"\n    VDOP\n}\nenum ChampTypeGSV {\n    /** Renvoie le nombre de satellites utilisés */\n    //% block=\"NBSAT (nb de satelittes utilisés)\"\n    NBSAT,\n    /** Renvoie la valeur de l'identifiant PRN du satellite choisi */\n    //% block=\"Identifiants PRN du Satellite choisi\"\n    ID,\n    /** Renvoie la valeur de l'élévation du satellite choisi (en Degré) */\n    //% block=\"ELEVATION du Satellite choisi (en Degré)\"\n    ELEVATION,\n    /** Renvoie la valeur de l'azimut du satellite choisi (en Degré) */\n    //% block=\"AZIMUT du Satellite choisi (en Degré)\"\n    AZIMUT,\n    /** Renvoie la valeur de la force de signal du satellite choisi (0 à 90 dB) */\n    //% block=\"FORCE du signal du Satellite choisi (0 à 90dB)\"\n    FORCE,\n}\nenum ChampTypeRMC {\n    /** Renvoie l'heure UTC au format HH:MM:SS.SSS*/\n    //% block=\"HEURE UTC (HH:MM:SS.SSS)\"\n    HEURE,\n    /** Renvoie la latitude en degré décimal*/\n    //% block=\"LATITUDE (Degré Décimal)\"\n    LATITUDE,\n    /** Renvoie la longitude en degré décimal*/\n    //% block=\"LONGITUDE (Degré Décimal)\"\n    LONGITUDE,\n    /** Renvoie un indicateur de status (\"A\" : valide, \"V\": non valide) */\n    //% block=\"ETAT ('A' : valide, 'V': non valide)\"\n    ETAT,\n    /** Renvoie la vitesse au sol en noeuds*/\n    //% block=\"VITESSE (en Noeuds)\"\n    VITESSE,\n    /** Renvoie la Route (Direction au sol parcouru en degré)*/\n    //% block=\"ROUTE (Direction au sol parcouru en degré)\"\n    ROUTE,\n    /** Renvoie la date UTC (JJ/MM/AA)*/\n    //% block=\"DATE UTC (JJ/MM/AA)\"\n    DATE\n}\nenum ChampTypeVTG {\n    /** Renvoie le CAP (Direction au sol actuel en degré)*/\n    //% block=\"CAP (Direction au sol actuel en degré)\"\n    CAP,\n    /** Renvoie la vitesse au sol en noeuds*/\n    //% block=\"VITESSE (en Noeuds)\"\n    VITESSENOEUD = 2,\n    /** Renvoie la vitesse au sol en km/h*/\n    //% block=\"VITESSE (en km/h)\"\n    VITESSEKMH\n}\nenum ChampTypeZDA {\n    /** Renvoie l'heure UTC au format HH:MM:SS.SSS*/\n    //% block=\"HEURE UTC (HH:MM:SS.SSS)\"\n    HEURE,\n    /** Renvoie la valeur du jour UTC entre 1 et 31*/\n    //% block=\"JOUR UTC (entre 1 et 31)\"\n    JOUR,\n    /** Renvoie la valeur du mois UTC entre 1 et 12*/\n    //% block=\"MOIS UTC (entre 1 et 12)\"\n    MOIS,\n    /** Renvoie la valeur de l'année UTC entre 1 et 12*/\n    //% block=\"ANNEE (AAAA)\"\n    ANNEE\n}\nenum ChampTypeSTR {\n    /** Renvoie l'heure UTC au format HH:MM:SS.SSS*/\n    //% block=\"HEURE UTC (HH:MM:SS.SSS)\"\n    HEURE,\n    /** Renvoie un indicateur de status (\"A\" : valide, \"V\": non valide) */\n    //% block=\"ETAT ('A' : valide, 'V': non valide)\"\n    ETAT,\n    /** Renvoie le type de mode \"A\" : Automatic ou \"M\" : Manuel*/\n    //% block=\"MODE ('A' : Automatic, 'M' : Manuel)\"\n    MODE,\n    /** Renvoie la date UTC (JJ/MM/AA)*/\n    //% block=\"DATE UTC (JJ/MM/AA)\"\n    DATE\n}\nenum ChampTypeNUM {\n    /** Renvoie la latitude en degré décimal*/\n    //% block=\"LATITUDE (Degré Décimal)\"\n    LATITUDE,\n    /** Renvoie la longitude en degré décimal*/\n    //% block=\"LONGITUDE (Degré Décimal)\"\n    LONGITUDE,\n    /** Renvoie la valeur du fix */\n    //% block=\"FIX (0 : non valide, >=1 : valide)\"\n    FIX,\n    /** Renvoie le type de fix (1 : Not available, 2: 2D, 3 : 3D) */\n    //% block=\"TYPE FIX (1 : Not available, 2: 2D, 3 : 3D)\"\n    FONCTIONNEMENT,\n    /** Renvoie le nombre de satellites utilisés */\n    //% block=\"NBSAT (nb de satelittes utilisés)\"\n    NBSAT,\n    /** Renvoie l'altitude en mètre */\n    //% block=\"ALTITUDE (en m)\"\n    ALTITUDE,\n    /** Renvoie la précision horizontale en mètre */\n    //% block=\"HDOP (précision lat/lon en m)\"\n    HDOP,\n    /** Renvoie la précision verticale en mètre */\n    //% block=\"VDOP (précision altitude en m)\"\n    VDOP,\n    /** Renvoie la précision globale en mètre */\n    //% block=\"PDOP (précision globale en m)\"\n    PDOP,\n    /** Renvoie la vitesse au sol en noeuds*/\n    //% block=\"VITESSE (en Noeuds)\"\n    VITESSENOEUD,\n    /** Renvoie la vitesse au sol en km/h*/\n    //% block=\"VITESSE (en km/h)\"\n    VITESSEKMH,\n    /** Renvoie la Route (Direction au sol parcouru en degré)*/\n    //% block=\"ROUTE (Direction au sol parcouru en degré)\"\n    ROUTE,\n    /** Renvoie le CAP (Direction au sol actuel en degré)*/\n    //% block=\"CAP (Direction au sol actuel en degré)\"\n    CAP,\n    /** Renvoie la valeur du jour UTC entre 1 et 31*/\n    //% block=\"JOUR UTC (entre 1 et 31)\"\n    JOUR,\n    /** Renvoie la valeur du mois UTC entre 1 et 12*/\n    //% block=\"MOIS UTC (entre 1 et 12)\"\n    MOIS,\n    /** Renvoie la valeur de l'année UTC entre 1 et 12*/\n    //% block=\"ANNEE (AAAA)\"\n    ANNEE\n}\n\nenum ChampTypeList {\n    /** Renvoie la valeur de l'identifiant PRN du satellite choisi */\n    //% block=\"Identifiants PRN du Satellite choisi\"\n    ID,\n    /** Renvoie la valeur de l'élévation du satellite choisi (en Degré) */\n    //% block=\"ELEVATION du Satellite choisi (en Degré)\"\n    ELEVATION,\n    /** Renvoie la valeur de l'azimut du satellite choisi (en Degré) */\n    //% block=\"AZIMUT du Satellite choisi (en Degré)\"\n    AZIMUT,\n    /** Renvoie la valeur de la force de signal du satellite choisi (0 à 90 dB) */\n    //% block=\"FORCE du signal du Satellite choisi (0 à 90dB)\"\n    FORCE,\n}\n\n\nnamespace GPS_AT6558 {\n\n    function toSerialPin(pin: mySerialPin): SerialPin {\n        return pin as any as SerialPin\n    }\n\n    function nomTrame(t: TrameType): string {\n        switch (t) {\n            case TrameType.GNGGA: return \"GNGGA\"\n            case TrameType.GNGLL: return \"GNGLL\"\n            case TrameType.GPGSA: return \"GPGSA\"\n            case TrameType.BDGSA: return \"BDGSA\"\n            case TrameType.GPGSV: return \"GPGSV\"\n            case TrameType.BDGSV: return \"BDGSV\"\n            case TrameType.GNRMC: return \"GNRMC\"\n            case TrameType.GNVTG: return \"GNVTG\"\n            case TrameType.GNZDA: return \"GNZDA\"\n            default: return \"\"\n        }\n    }\n\n    /**\n        *Initialise le GPS sur la broche choisie                  \n    */\n    //% block=\"initialiser GPS sur broche %rx (sans maj auto)\"\n    //% rx.fieldEditor=\"gridpicker\"\n    //% rx.fieldOptions.columns=3\n    //% rx.defl=mySerialPin.P0\n    //% weight=20\n    //% subcategory=\"Avancé : Trames NMEA\"\n    export function initGps(rx: mySerialPin): void {\n        serial.redirect(SerialPin.USB_TX, toSerialPin(rx), 9600)\n        serial.setTxBufferSize(128)\n        serial.setRxBufferSize(128)\n        serial.readUntil(\"\\n\") // nettoyer une trame éventuelle en attente\n    }\n\n    /**\n        Retourne une chaîne de caractère correspondante au type de trame NMEA choisie.\n    **/\n    //% block=\"Récupérer une trame $identifiant avec un timeout de $timeout\"\n    //% identifiant.defl=TrameType.GNGGA\n    //% timeout.defl=5000 \n    //% weight=19\n    //% subcategory=\"Avancé : Trames NMEA\"\n    //% inlineInputMode=external\n    export function getTrameNMEA(identifiant: TrameType, timeout: number): string {\n        let idTrame = nomTrame(identifiant)\n        let start = control.millis()\n\n        // Si ce sont des trames GSV, on prépare à les collecter toutes\n        if (idTrame == \"GPGSV\" || idTrame == \"BDGSV\") {\n            let trames: string[] = []\n            let compteur = 0\n            while (control.millis() - start < 3 * timeout) {\n                const trame = serial.readUntil(\"\\n\").trim()\n                if (trame && trame.includes(\",\")) {\n                    let champs = trame.split(\",\")\n                    let id = champs[0]\n                    if (id == \"$\" + idTrame) {\n                        let numTrame = parseInt(champs[2])      // numéro de cette trame (1, 2, ...)\n                        let totalTrames = parseInt(champs[1])   // nombre total de trames\n\n                        if (!trames[numTrame - 1]) {\n                            trames[numTrame - 1] = trame         // on place la trame à la bonne position\n                            compteur += 1\n                        }\n\n                        // Si on a reçu toutes les trames, on les renvoie dans l'ordre\n                        if (compteur == totalTrames) {\n                            return trames.join(\"@\")\n                        }\n                    }\n                }\n                basic.pause(10)\n            }\n            return trames.join(\"@\") // Même si incomplètes\n        }\n        while (control.millis() - start < timeout) {\n            const trame2 = serial.readUntil(\"\\n\").trim()\n            if (trame2 && trame2.includes(\",\")) {\n                let id2 = trame2.split(\",\")[0]\n                if (id2 == \"$\" + idTrame) {\n                    return trame2\n                }\n            }\n            basic.pause(10)\n        }\n        return \"\"\n    }\n\n    /** \n        Retourne une valeur numérique du checksum (0–255) d'une trame\n    **/\n    //% block=\"Calcul Checksum d'une trame $trame\"\n    //% weight=3\n    //% subcategory=\"Checksum\"\n    export function calculateChecksum(trame: string): number {\n        // Vérifie que la trame commence bien par '$' et contient '*'\n        if (trame.charAt(0) != \"$\" || trame.indexOf(\"*\") == -1) {\n            return -1\n        }\n        // Extrait la portion entre $ et *\n        let start2 = 1\n        let end = trame.indexOf(\"*\")\n        let data = trame.slice(start2, end)\n\n        // Calcule le XOR de tous les caractères\n        let checksum = 0\n        for (let i = 0; i < data.length; i++) {\n            checksum ^= data.charCodeAt(i)\n        }\n        return checksum\n    }\n\n    /** \n        Retourne un booléen indiquant si le checksum de la trame est bon\n    **/\n    //% block=\"Validation d'une trame $trame\"\n    //% weight=2\n    //% subcategory=\"Checksum\"\n    export function checkTrame(trame: string): boolean {\n        let sepIndex = trame.indexOf(\"*\")\n        if (trame.charAt(0) != \"$\" || sepIndex == -1) {\n            return false\n        }\n        let expected = parseInt(trame.slice(sepIndex + 1, sepIndex + 3), 16)\n        let actual = calculateChecksum(trame)\n        return expected == actual\n    }\n\n    /** Retourne une chaîne de caractère du champ chosie de la trame GNGGA.*/\n    //% block=\"Lire $champ dans la trame GNGGA $trame\"\n    //% champ.defl=ChampTypeGGA.HEURE\n    //% trame.defl=\"\"\n    //% weight=18\n    //% subcategory=\"Avancé : Trames NMEA\"\n    //% inlineInputMode=external\n    export function getValueGNGGA(champ: ChampTypeGGA, trame: string): string {\n        if (trame == \"\" || !checkTrame(trame)) {\n            return \"\"\n        }\n        let champs2 = trame.split(\",\")\n        switch (champ) {\n            case ChampTypeGGA.HEURE:\n                return (champs2[1].slice(0, 2) + \":\" + champs2[1].slice(2, 4) + \":\" + champs2[1].slice(4))\n            case ChampTypeGGA.LATITUDE:\n                let degLat = parseFloat(champs2[2].slice(0, 2))\n                let minLat = parseFloat(champs2[2].slice(2))\n                let latitude = degLat + minLat / 60\n                if (champs2[3] == \"S\") {\n                    latitude = -latitude\n                }\n                return latitude.toString()\n            case ChampTypeGGA.LONGITUDE:\n                let degLon = parseFloat(champs2[4].slice(0, 3))\n                let minLon = parseFloat(champs2[4].slice(3))\n                let longitude = degLon + minLon / 60\n                if (champs2[5] == \"W\") {\n                    longitude = -longitude\n                }\n                return longitude.toString()\n            case ChampTypeGGA.FIX:\n                return champs2[6]\n            case ChampTypeGGA.NBSAT:\n                return champs2[7]\n            case ChampTypeGGA.ALTITUDE:\n                return champs2[9]\n            case ChampTypeGGA.HDOP:\n                return champs2[8]\n            case ChampTypeGGA.VDOP:\n                return champs2[11]\n            default:\n                return \"\"\n        }\n    }\n\n    /** Retourne une chaîne de caractère du champ chosie de la trame GNGLL.*/\n    //% block=\"Lire $champ dans la trame GNGLL $trame\"\n    //% champ.defl=ChampTypeGLL.ETAT\n    //% weight=17\n    //% subcategory=\"Avancé : Trames NMEA\"\n    //% inlineInputMode=external\n    export function getValueGNGLL(champ: ChampTypeGLL, trame: string): string {\n        if (trame == \"\" || !checkTrame(trame)) {\n            return \"\"\n        }\n        let champs3 = trame.split(\",\")\n        switch (champ) {\n            case ChampTypeGLL.HEURE:\n                return (champs3[5].slice(0, 2) + \":\" + champs3[5].slice(2, 4) + \":\" + champs3[5].slice(4))\n            case ChampTypeGLL.LATITUDE:\n                let degLat2 = parseFloat(champs3[1].slice(0, 2))\n                let minLat2 = parseFloat(champs3[1].slice(2))\n                let latitude2 = degLat2 + minLat2 / 60\n                if (champs3[2] == \"S\") {\n                    latitude2 = -latitude2\n                }\n                return latitude2.toString()\n            case ChampTypeGLL.LONGITUDE:\n                let degLon2 = parseFloat(champs3[3].slice(0, 3))\n                let minLon2 = parseFloat(champs3[3].slice(3))\n                let longitude2 = degLon2 + minLon2 / 60\n                if (champs3[4] == \"W\") {\n                    longitude2 = -longitude2\n                }\n                return longitude2.toString()\n            case ChampTypeGLL.ETAT:\n                return champs3[6]\n            default:\n                return \"\"\n        }\n    }\n\n    /** Retourne une chaîne de caractère du champ chosie de la trame GPGSA ou BDGSA.*/\n    //% block=\"Lire $champ dans la trame GPGSA ou BDGSA $trame\"\n    //% champ.defl=ChampTypeGSA.SELECTION\n    //% weight=16\n    //% subcategory=\"Avancé : Trames NMEA\"\n    //% inlineInputMode=external\n    export function getValueGPGSABDGSA(champ: ChampTypeGSA, trame: string): string {\n        if (trame == \"\" || !checkTrame(trame)) {\n            return \"\"\n        }\n        let champs4 = trame.split(\",\")\n        switch (champ) {\n            case ChampTypeGSA.MODE:\n                return champs4[1]\n            case ChampTypeGSA.FONCTIONNEMENT:\n                return champs4[2]\n            case ChampTypeGSA.IDSAT:\n                let id3 = \"\"\n                for (let j = 3; j < 14; j++) {\n                    if (champs4[j] != \"\") {\n                        id3 = id3 + champs4[j] + \" \"\n                    }\n                }\n                id3.trim()\n                return id3\n            case ChampTypeGSA.PDOP:\n                return champs4[15]\n            case ChampTypeGSA.HDOP:\n                return champs4[16]\n            case ChampTypeGSA.VDOP:\n                let end2 = champs4[17].indexOf(\"*\")\n                return champs4[17].slice(0, end2)\n            default:\n                return \"\"\n        }\n    }\n\n    /** Retourne une chaîne de caractère du champ chosie de la trame GPGS ou BDGSV.*/\n    //% block=\"Lire $champ dans la trame GPGSV ou BDGSV $trame du satellite $numero\"\n    //% champ.defl=ChampTypeGSV.ID\n    //% numero.defl=1\n    //% weight=15\n    //% subcategory=\"Avancé : Trames NMEA\"\n    //% inlineInputMode=external\n    export function getValueGPGSVBDGSV(champ: ChampTypeGSV, trame: string, numero: number): string {\n        let trames2 = trame.split(\"@\")\n        for (let k = 0; k < trames2.length; k++) {\n            if (trames2[k] == \"\" || !checkTrame(trames2[k])) {\n                return \"\"\n            }\n        }\n        switch (champ) {\n            case ChampTypeGSV.NBSAT:\n                return trames2[0].split(\",\")[3]\n            case ChampTypeGSV.ID:\n                if (numero < 1 || numero > parseInt(trames2[0].split(\",\")[3])) {\n                    return \"\"\n                }\n                else {\n                    return trames2[Math.floor((numero - 1) / 4)].split(\",\")[4 + (numero - 1) % 4 * 4]\n                }\n            case ChampTypeGSV.ELEVATION:\n                if (numero < 1 || numero > parseInt(trames2[0].split(\",\")[3])) {\n                    return \"\"\n                }\n                else {\n                    return trames2[Math.floor((numero - 1) / 4)].split(\",\")[5 + (numero - 1) % 4 * 4]\n                }\n            case ChampTypeGSV.AZIMUT:\n                if (numero < 1 || numero > parseInt(trames2[0].split(\",\")[3])) {\n                    return \"\"\n                }\n                else {\n                    return trames2[Math.floor((numero - 1) / 4)].split(\",\")[6 + (numero - 1) % 4 * 4]\n                }\n            case ChampTypeGSV.FORCE:\n                if (numero < 1 || numero > parseInt(trames2[0].split(\",\")[3])) {\n                    return \"\"\n                }\n                else {\n                    let force = trames2[Math.floor((numero - 1) / 4)].split(\",\")[7 + (numero - 1) % 4 * 4]\n                    let pos = force.indexOf(\"*\")\n                    if (pos == -1) {\n                        return force\n                    }\n                    else {\n                        return force.slice(0, pos)\n                    }\n\n                }\n            default:\n                return \"\"\n        }\n    }\n\n    /** Retourne une chaîne de caractère du champ chosie de la trame GNRMC.*/\n    //% block=\"Lire $champ dans la trame GNRMC $trame\"\n    //% champ.defl=ChampTypeRMC.ROUTE\n    //% weight=14\n    //% subcategory=\"Avancé : Trames NMEA\"\n    //% inlineInputMode=external\n    export function getValueGNRMC(champ: ChampTypeRMC, trame: string): string {\n        if (trame == \"\" || !checkTrame(trame)) {\n            return \"\"\n        }\n        let champs5 = trame.split(\",\")\n        switch (champ) {\n            case ChampTypeRMC.HEURE:\n                return (champs5[1].slice(0, 2) + \":\" + champs5[1].slice(2, 4) + \":\" + champs5[1].slice(4))\n            case ChampTypeRMC.LATITUDE:\n                let degLat3 = parseFloat(champs5[3].slice(0, 2))\n                let minLat3 = parseFloat(champs5[3].slice(2))\n                let latitude3 = degLat3 + minLat3 / 60\n                if (champs5[4] == \"S\") {\n                    latitude3 = -latitude3\n                }\n                return latitude3.toString()\n            case ChampTypeRMC.LONGITUDE:\n                let degLon3 = parseFloat(champs5[5].slice(0, 3))\n                let minLon3 = parseFloat(champs5[5].slice(3))\n                let longitude3 = degLon3 + minLon3 / 60\n                if (champs5[6] == \"W\") {\n                    longitude3 = -longitude3\n                }\n                return longitude3.toString()\n            case ChampTypeRMC.ETAT:\n                return champs5[2]\n            case ChampTypeRMC.VITESSE:\n                return champs5[7]\n            case ChampTypeRMC.ROUTE:\n                return champs5[8]\n            case ChampTypeRMC.DATE:\n                return (champs5[9].slice(0, 2) + \"/\" + champs5[9].slice(2, 4) + \"/\" + champs5[9].slice(4))\n            default:\n                return \"\"\n        }\n\n    }\n\n    /** Retourne une chaîne de caractère du champ chosie de la trame GNVTG.*/\n    //% block=\"Lire $champ dans la trame GNVTG $trame\"\n    //% champ.defl=ChampTypeVTG.CAP\n    //% weight=13\n    //% subcategory=\"Avancé : Trames NMEA\"\n    //% inlineInputMode=external\n    export function getValueGNVTG(champ: ChampTypeVTG, trame: string): string {\n        if (trame == \"\" || !checkTrame(trame)) {\n            return \"\"\n        }\n        let champs6 = trame.split(\",\")\n        switch (champ) {\n            case ChampTypeVTG.CAP:\n                return champs6[1]\n            case ChampTypeVTG.VITESSENOEUD:\n                return champs6[5]\n            case ChampTypeVTG.VITESSEKMH:\n                return champs6[7]\n            default:\n                return \"\"\n        }\n    }\n\n    /** Retourne une chaîne de caractère du champ chosie de la trame GNZDA.*/\n    //% block=\"Lire $champ dans la trame GNZDA $trame\"\n    //% champ.defl=ChampTypeZDA.JOUR\n    //% weight=12\n    //% subcategory=\"Avancé : Trames NMEA\"\n    //% inlineInputMode=external\n    export function getValueGNZDA(champ: ChampTypeZDA, trame: string): string {\n        if (trame == \"\" || !checkTrame(trame)) {\n            return \"\"\n        }\n        let champs7 = trame.split(\",\")\n        switch (champ) {\n            case ChampTypeZDA.HEURE:\n                return (champs7[1].slice(0, 2) + \":\" + champs7[1].slice(2, 4) + \":\" + champs7[1].slice(4))\n            case ChampTypeZDA.JOUR:\n                return champs7[2]\n            case ChampTypeZDA.MOIS:\n                return champs7[3]\n            case ChampTypeZDA.ANNEE:\n                return champs7[4]\n            default:\n                return \"\"\n        }\n    }\n\n    /** Retourne un booléen indiquant si le module récupère des coordonnées.*/\n    //% block=\"Module prêt ? \"\n    //% weight=99\n    //% group=\"Initialisation du module\"\n    export function hasFix(): boolean {\n        let trame3 = getTrameNMEA(TrameType.GNGGA, 5000)\n        let fixStr = getValueGNGGA(ChampTypeGGA.FIX, trame3)\n        let fix = parseInt(fixStr)\n        let trame22 = getTrameNMEA(TrameType.GNRMC, 5000)\n        let etat = getValueGNRMC(ChampTypeRMC.ETAT, trame22)\n        let trame32 = getTrameNMEA(TrameType.GNGLL, 5000)\n        let etat2 = getValueGNGLL(ChampTypeGLL.ETAT, trame32)\n        return !isNaN(fix) && fix >= 1 && etat == \"A\" && etat2 == \"A\"\n    }\n\n\n\n    class GPS {\n        private latitude: number\n        private longitude: number\n        private fix: number\n        private nbsat: number\n        private altitude: number\n        private hdop: number\n        private vdop: number\n        private pdop: number\n        private vitesseNoeuds: number\n        private vitesseKmH: number\n        private route: number\n        private cap: number\n        private jour: number\n        private mois: number\n        private annee: number\n        private fonctionnement: number\n\n        private heureUTC: string\n        private date: string\n        private etat: string\n        private mode: string\n\n        private taille: number\n        private ids: number[]\n        private elevations: number[]\n        private azimuts: number[]\n        private forces: number[]\n\n        private enMarche: boolean\n\n        constructor() {\n            this.enMarche = false\n            this.latitude = NaN\n            this.longitude = NaN\n            this.fix = NaN\n            this.nbsat = NaN\n            this.altitude = NaN\n            this.hdop = NaN\n            this.vdop = NaN\n            this.pdop = NaN\n            this.vitesseNoeuds = NaN\n            this.vitesseKmH = NaN\n            this.route = NaN\n            this.cap = NaN\n            this.jour = NaN\n            this.mois = NaN\n            this.annee = NaN\n            this.fonctionnement = NaN\n\n            this.heureUTC = \"\"\n            this.date = \"\"\n            this.etat = \"\"\n            this.mode = \"\"\n            this.taille = 24\n            this.ids = []\n            this.elevations = []\n            this.azimuts = []\n            this.forces = []\n            for (let i = 0; i < this.taille; i++) {\n                this.ids.push(NaN)\n                this.elevations.push(NaN)\n                this.azimuts.push(NaN)\n                this.forces.push(NaN)\n            }\n\n\n\n        }\n        public demarrer(): void {\n            this.enMarche = true\n            control.inBackground(() => {\n                while (this.enMarche) {\n                    let trame4 = getTrameNMEA(TrameType.GNGGA, 2000)\n                    if (trame4 != \"\") {\n                        this.heureUTC = getValueGNGGA(ChampTypeGGA.HEURE, trame4)\n                        this.latitude = parseFloat(getValueGNGGA(ChampTypeGGA.LATITUDE, trame4))\n                        this.longitude = parseFloat(getValueGNGGA(ChampTypeGGA.LONGITUDE, trame4))\n                        this.fix = parseInt(getValueGNGGA(ChampTypeGGA.FIX, trame4))\n                        this.nbsat = parseInt(getValueGNGGA(ChampTypeGGA.NBSAT, trame4))\n                        this.altitude = parseFloat(getValueGNGGA(ChampTypeGGA.ALTITUDE, trame4))\n                        this.hdop = parseFloat(getValueGNGGA(ChampTypeGGA.HDOP, trame4))\n                        this.vdop = parseFloat(getValueGNGGA(ChampTypeGGA.VDOP, trame4))\n                    }\n                    trame4 = getTrameNMEA(TrameType.GPGSA, 2000)\n                    if (trame4 != \"\") {\n                        this.mode = getValueGPGSABDGSA(ChampTypeGSA.MODE, trame4)\n                        this.fonctionnement = parseInt(getValueGPGSABDGSA(ChampTypeGSA.FONCTIONNEMENT, trame4))\n                        this.pdop = parseFloat(getValueGPGSABDGSA(ChampTypeGSA.PDOP, trame4))\n                    }\n                    trame4 = getTrameNMEA(TrameType.GNRMC, 2000)\n                    if (trame4 != \"\") {\n                        this.date = getValueGNRMC(ChampTypeRMC.DATE, trame4)\n                        this.route = parseFloat(getValueGNRMC(ChampTypeRMC.ROUTE, trame4))\n                        this.etat = getValueGNRMC(ChampTypeRMC.ETAT, trame4)\n                        this.vitesseNoeuds = parseFloat(getValueGNRMC(ChampTypeRMC.VITESSE, trame4))\n                    }\n                    trame4 = getTrameNMEA(TrameType.GNVTG, 2000)\n                    if (trame4 != \"\") {\n                        this.cap = parseFloat(getValueGNVTG(ChampTypeVTG.CAP, trame4))\n                        this.vitesseKmH = parseFloat(getValueGNVTG(ChampTypeVTG.VITESSEKMH, trame4))\n\n                    }\n                    trame4 = getTrameNMEA(TrameType.GNZDA, 2000)\n                    if (trame4 != \"\") {\n                        this.jour = parseInt(getValueGNZDA(ChampTypeZDA.JOUR, trame4))\n                        this.mois = parseInt(getValueGNZDA(ChampTypeZDA.MOIS, trame4))\n                        this.annee = parseInt(getValueGNZDA(ChampTypeZDA.ANNEE, trame4))\n                    }\n                    trame4 = getTrameNMEA(TrameType.BDGSV, 2000)\n                    let nb = 0\n                    if (trame4 != \"\") {\n                        nb = parseInt(getValueGPGSVBDGSV(ChampTypeGSV.NBSAT, trame4, 1))\n                        for (let i = 0; i < nb; i++) {\n                            this.ids[i] = parseInt(getValueGPGSVBDGSV(ChampTypeGSV.ID, trame4, i + 1))\n                            this.elevations[i] = parseFloat(getValueGPGSVBDGSV(ChampTypeGSV.ELEVATION, trame4, i + 1))\n                            this.forces[i] = parseFloat(getValueGPGSVBDGSV(ChampTypeGSV.FORCE, trame4, i + 1))\n                            this.azimuts[i] = parseFloat(getValueGPGSVBDGSV(ChampTypeGSV.AZIMUT, trame4, i + 1))\n                        }\n                    }\n                    trame4 = getTrameNMEA(TrameType.GPGSV, 2000)\n                    if (trame4 != \"\") {\n                        let nb2 = parseInt(getValueGPGSVBDGSV(ChampTypeGSV.NBSAT, trame4, 1))\n                        for (let i = 0; i < nb2; i++) {\n                            this.ids[nb + i] = parseInt(getValueGPGSVBDGSV(ChampTypeGSV.ID, trame4, i + 1))\n                            this.elevations[nb + i] = parseFloat(getValueGPGSVBDGSV(ChampTypeGSV.ELEVATION, trame4, i + 1))\n                            this.forces[nb + i] = parseFloat(getValueGPGSVBDGSV(ChampTypeGSV.FORCE, trame4, i + 1))\n                            this.azimuts[nb + i] = parseFloat(getValueGPGSVBDGSV(ChampTypeGSV.AZIMUT, trame4, i + 1))\n                        }\n                    }\n                }\n            })\n        }\n        public getLatitude(): number {\n            return this.latitude\n        }\n        public getLongitude(): number {\n            return this.longitude\n        }\n        public getFix(): number {\n            return this.fix\n        }\n        public getNbSat(): number {\n            return this.nbsat\n        }\n        public getAltitude(): number {\n            return this.altitude\n        }\n        public getHDOP(): number {\n            return this.hdop\n        }\n        public getVDOP(): number {\n            return this.vdop\n        }\n        public getPDOP(): number {\n            return this.pdop\n        }\n        public getVitesseN(): number {\n            return this.vitesseNoeuds\n        }\n        public getVitesseK(): number {\n            return this.vitesseKmH\n        }\n        public getRoute(): number {\n            return this.route\n        }\n        public getCap(): number {\n            return this.cap\n        }\n        public getJour(): number {\n            return this.jour\n        }\n        public getMois(): number {\n            return this.mois\n        }\n        public getAnnee(): number {\n            return this.annee\n        }\n        public getFonctionnement(): number {\n            return this.fonctionnement\n        }\n        public getHeure(): string {\n            return this.heureUTC\n        }\n        public getDate(): string {\n            return this.date\n        }\n        public getEtat(): string {\n            return this.etat\n        }\n        public getMode(): string {\n            return this.mode\n        }\n        public getId(nombre: number): number {\n            return this.ids[nombre]\n        }\n        public getElevation(nombre: number): number {\n            return this.elevations[nombre]\n        }\n        public getAzimut(nombre: number): number {\n            return this.azimuts[nombre]\n        }\n        public getForces(nombre: number): number {\n            return this.forces[nombre]\n        }\n        public arreter() {\n            this.enMarche = false\n        }\n    }\n\n    let gps = new GPS()\n    // Fonctions exportées vers MakeCode (sous forme de blocs)\n\n    /**Initialise le GPS sur la broche choisie*/\n    //% block=\"initialiser GPS sur broche %rx\"\n    //% rx.fieldEditor=\"gridpicker\"\n    //% rx.fieldOptions.columns=3\n    //% rx.defl=mySerialPin.P0\n    //% weight=100\n    //% group=\"Initialisation du module\"\n    export function initGpsv2(rx: mySerialPin): void {\n        serial.redirect(SerialPin.USB_TX, toSerialPin(rx), 9600)\n        serial.setTxBufferSize(128)\n        serial.setRxBufferSize(128)\n        serial.readUntil(\"\\n\") // nettoyer une trame éventuelle\n        gps.demarrer()\n    }\n\n    /** Retourne une chaîne de caractère du champ chosie*/\n    //% block=\"Lire chaîne $champ\"\n    //% champ.defl=ChampTypeSTR.HEURE\n    //% weight=99\n    //% group=\"GPS\"\n    export function getValueStr(champ: ChampTypeSTR): string {\n        switch (champ) {\n            case ChampTypeSTR.HEURE:\n                return gps.getHeure()\n            case ChampTypeSTR.ETAT:\n                return gps.getEtat()\n            case ChampTypeSTR.MODE:\n                return gps.getMode()\n            case ChampTypeSTR.DATE:\n                return gps.getDate()\n            default:\n                return \"\"\n        }\n    }\n\n    /** Retourne la valeur du nombre du champ chosie*/\n    //% block=\"Lire nombre $champ\"\n    //% champ.defl=ChampTypeNUM.LATITUDE\n    //% weight=98\n    //% group=\"GPS\"\n    export function getValueNbr(champ: ChampTypeNUM): number {\n        switch (champ) {\n            case ChampTypeNUM.LATITUDE:\n                return gps.getLatitude()\n            case ChampTypeNUM.LONGITUDE:\n                return gps.getLongitude()\n            case ChampTypeNUM.FIX:\n                return gps.getFix()\n            case ChampTypeNUM.NBSAT:\n                return gps.getNbSat()\n            case ChampTypeNUM.ALTITUDE:\n                return gps.getAltitude()\n            case ChampTypeNUM.HDOP:\n                return gps.getHDOP()\n            case ChampTypeNUM.VDOP:\n                return gps.getVDOP()\n            case ChampTypeNUM.PDOP:\n                return gps.getPDOP()\n            case ChampTypeNUM.VITESSENOEUD:\n                return gps.getVitesseN()\n            case ChampTypeNUM.VITESSEKMH:\n                return gps.getVitesseK()\n            case ChampTypeNUM.ROUTE:\n                return gps.getRoute()\n            case ChampTypeNUM.CAP:\n                return gps.getCap()\n            case ChampTypeNUM.JOUR:\n                return gps.getJour()\n            case ChampTypeNUM.MOIS:\n                return gps.getMois()\n            case ChampTypeNUM.ANNEE:\n                return gps.getAnnee()\n            case ChampTypeNUM.FONCTIONNEMENT:\n                return gps.getFonctionnement()\n            default:\n                return NaN\n        }\n    }\n\n    /** Retourne la valeur du nombre du champ chosie*/\n    //% block=\"Lire nombre $champ du satellite $numero\"\n    //% champ.defl=ChampTypeList.ID\n    //% numero.defl=1\n    //% weight=97\n    //% group=\"GPS\"\n    export function getValueList(champ: ChampTypeList, numero: number): number {\n        switch (champ) {\n            case ChampTypeList.ID:\n                return gps.getId(numero - 1)\n            case ChampTypeList.ELEVATION:\n                return gps.getElevation(numero - 1)\n            case ChampTypeList.AZIMUT:\n                return gps.getAzimut(numero - 1)\n            case ChampTypeList.FORCE:\n                return gps.getForces(numero - 1)\n            default:\n                return NaN\n        }\n    }\n\n    //% block=\"Arrêter GPS\"\n    //% group=\"Initialisation du module\"\n    //% weight=96\n    export function arreterGPS() {\n        gps.arreter()\n    }\n\n\n\n    /** Retourne la valeur numérique de la distance entre le point A et le point B*/\n    //% block=\"Distance entre |A $latA $longA et |B $latB $longB (en m)\"\n    //% latA.defl=49.2147928\n    //% longA.defl=-0.3675902\n    //% latB.defl=46.6703886\n    //% longB.defl=0.3701164\n    //% weight=99\n    //% group=\"Cap et distance\"\n    //% inlineInputMode=external\n    export function calcul_distance(latA: number, longA: number, latB: number, longB: number): number {\n        latA = latA * Math.PI / 180\n        longA = longA * Math.PI / 180\n        latB = latB * Math.PI / 180\n        longB = longB * Math.PI / 180\n        let R = 6372795.477598\n        let distance = R * Math.acos(Math.sin(latA) * Math.sin(latB) + Math.cos(latA) * Math.cos(latB) * Math.cos(longA - longB))\n        return Math.trunc(distance)\n    }\n\n    /** Affiche une flèche en fonction de l'angle passé en argument*/\n    //% block=\"Affiche une flèche en fonction de l'angle $angle\"\n    //% weight=98\n    //% group=\"Cap et distance\"\n    //% inlineInputMode=external\n    export function affichage(angle: number): void {\n        if (angle <= 22.5 || angle >= 337.5) {\n            basic.showArrow(ArrowNames.North)\n        } else if (angle <= 67.5) {\n            basic.showArrow(ArrowNames.NorthEast)\n        } else if (angle <= 112.5) {\n            basic.showArrow(ArrowNames.East)\n        } else if (angle <= 157.5) {\n            basic.showArrow(ArrowNames.SouthEast)\n        } else if (angle <= 202.5) {\n            basic.showArrow(ArrowNames.South)\n        } else if (angle <= 247.5) {\n            basic.showArrow(ArrowNames.SouthWest)\n        } else if (angle <= 292.5) {\n            basic.showArrow(ArrowNames.West)\n        } else if (angle < 337.5) {\n            basic.showArrow(ArrowNames.NorthWest)\n        }\n    }\n\n    /** Retourne la valeur numérique du cap en degré entre la coordonnée A et B*/\n    //% block=\"Cap entre |A $latA $longA et |B $latB $longB (em degré)\"\n    //% latA.defl=49.2147928\n    //% longA.defl=-0.3675902\n    //% latB.defl=46.6703886\n    //% longB.defl=0.3701164\n    //% weight=100\n    //% group=\"Cap et distance\"\n    //% inlineInputMode=external\n    export function calcul_cap(latA: number, longA: number, latB: number, longB: number): number {\n        latA = latA * Math.PI / 180\n        longA = longA * Math.PI / 180\n        latB = latB * Math.PI / 180\n        longB = longB * Math.PI / 180\n        let phi = Math.log(Math.tan(latB / 2 + Math.PI / 4) / Math.tan(latA / 2 + Math.PI / 4))\n        let lo = longB - longA\n        let roulement = (Math.atan2(lo, phi) * 360 / (2 * Math.PI) + 360) % 360\n        return roulement\n    }\n\n}"],[1,"\n"]],"start1":0,"start2":0,"length1":37890,"length2":1}]},{"type":"edited","filename":"pxt.json","patch":[{"diffs":[[0,"   \""],[-1,"testFiles\": [\n        \"test.ts\"\n    ],\n    \"preferredEditor\": \"tsprj\""],[1,"additionalFilePaths\": []"],[0,"\n}\n"]],"start1":232,"start2":232,"length1":76,"length2":31}]},{"type":"added","filename":"test.ts","value":"// les tests vont ici ; cela ne sera pas compilé si ce paquet est utilisé en tant qu'extension.\n"}]}],"snapshots":[{"timestamp":1749565338955,"editorVersion":"7.0.61","text":{"main.blocks":"<xml xmlns=\"http://www.w3.org/1999/xhtml\">\n  <block type=\"pxt-on-start\"></block>\n  <block type=\"device_forever\"></block>\n</xml>","main.ts":"\n","README.md":"","pxt.json":"{\n    \"name\": \"Unit_GPS\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\"\n    ],\n    \"additionalFilePaths\": []\n}\n"}}],"shares":[],"lastSaveTime":1749565472312}